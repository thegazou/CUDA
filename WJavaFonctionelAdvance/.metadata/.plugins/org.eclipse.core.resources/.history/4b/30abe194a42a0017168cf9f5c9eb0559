
package ch.arc.cours.lamda.interfacefonctionelle.neu.existant.function;

import java.util.List;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.ToIntFunction;

import ch.arc.cours.lamda.interfacefonctionelle.neu.existant.function.tools.Maison;

public class MaisonManipulator
	{

	/*------------------------------------------------------------------*\
	|*							Methodes Public							*|
	\*------------------------------------------------------------------*/

	/**
	 * see chapter stream to see beautiful flexible optimized code
	 */
	public static void mapPrint(List<Maison> list, Function<Maison, Integer> function)
		{
		for(Maison maison:list)
			{
			// TODO
			System.out.println(attribut);
			}
		}

	/**
	 * see chapter stream to see beautiful flexible optimized code
	 */
	public static void mapPrint(List<Maison> list, ToIntFunction<Maison> function)
		{
		for(Maison maison:list)
			{
			// TODO
			System.out.println(attribut);
			}
		}

	/**
	 * see chapter stream to see beautiful flexible optimized code
	 */
	public static int mapReduce(List<Maison> list, Function<Maison, Integer> function, BinaryOperator<Integer> operator, int initValue)
		{
		int value = initValue;
		for(Maison maison:list)
			{
			// TODO
			}

		return value;
		}

	/**
	 * see chapter stream to see beautiful flexible optimized code
	 */
	public static int filterMapReduce(List<Maison> list, Predicate<Maison> predicate, Function<Maison, Integer> function, BinaryOperator<Integer> operator, int initValue)
		{
		int value = initValue;
		for(Maison maison:list)
			{
			if (predicate.test(maison))
				{
				// TODO
				}
			}

		return value;
		}

	/*------------------------------------------------------------------*\
	|*							Methodes Private						*|
	\*------------------------------------------------------------------*/

	}
